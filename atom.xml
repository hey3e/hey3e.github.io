<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HEY3E</title>
  
  
  <link href="https://hey3e.github.io/atom.xml" rel="self"/>
  
  <link href="https://hey3e.github.io/"/>
  <updated>2021-12-29T14:00:24.098Z</updated>
  <id>https://hey3e.github.io/</id>
  
  <author>
    <name>hey3e</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSec系列 - 2. JNDI注入</title>
    <link href="https://hey3e.github.io/2021/12/29/JavaSec%E7%B3%BB%E5%88%97-2-JNDI%E6%B3%A8%E5%85%A5/"/>
    <id>https://hey3e.github.io/2021/12/29/JavaSec%E7%B3%BB%E5%88%97-2-JNDI%E6%B3%A8%E5%85%A5/</id>
    <published>2021-12-29T13:39:16.000Z</published>
    <updated>2021-12-29T14:00:24.098Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章源码： &lt;a href=&quot;https://github.com/hey3e/JavaSec-Code/tree/main/javasec2&quot;&gt;https://github.com/hey3e/JavaSec-Code/tree/main/javasec2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命名与目录系统 (Naming and Directory services)，如&lt;strong&gt;RMI&lt;/strong&gt; (Remote Method Invocation)、&lt;strong&gt;LDAP&lt;/strong&gt; (Lightweight Directory Access Protocol) 等，能够以类似字典&lt;code&gt;key-value&lt;/code&gt;的&lt;code&gt;name-object&lt;/code&gt;形式对对象进行存储，使得我们可以通过名称来查询并访问对象。&lt;strong&gt;JNDI&lt;/strong&gt; (Java Naming and Directory Interface) 便是该过程的接口。&lt;/p&gt;
&lt;p&gt;结合上一章的知识，我们考虑在系统中存储对象序列化后的字节流，当用户进行查询时，系统返回对应的字节流，用户再进行反序列化获取对象。但在实际场景中，如果对象过大，采用该方式往往会给系统带来一定的负担。&lt;/p&gt;
&lt;p&gt;于是，JNDI使用&lt;code&gt;Naming References&lt;/code&gt;的方式进行存储，此时，&lt;code&gt;name-object&lt;/code&gt;中的&lt;code&gt;object&lt;/code&gt;并非对象本身，而是对象的引用&lt;code&gt;Reference&lt;/code&gt;，其中包含对象名及其真正被存放的地址codebase。当用户进行查询时，系统返回&lt;code&gt;Reference&lt;/code&gt;，用户解析后再从codebase获取对象。&lt;strong&gt;不过这里说的不太严谨，后面会进行补充&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过，上述从远程codebase加载对象的方式存在许多安全问题，随着jdk版本的迭代，系统对codebase已逐渐不再信任，JNDI受到越来越多的限制。我们下面看一下各版本下JNDI如何实现。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSec" scheme="https://hey3e.github.io/categories/JavaSec/"/>
    
    
    <category term="JNDI" scheme="https://hey3e.github.io/tags/JNDI/"/>
    
  </entry>
  
  <entry>
    <title>JavaSec系列 - 1. 反序列化与反射</title>
    <link href="https://hey3e.github.io/2021/12/22/JavaSec%E7%B3%BB%E5%88%97-1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>https://hey3e.github.io/2021/12/22/JavaSec%E7%B3%BB%E5%88%97-1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2021-12-22T13:45:42.000Z</published>
    <updated>2021-12-27T13:01:10.154Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章源码： &lt;a href=&quot;https://github.com/hey3e/JavaSec-Code/tree/main/javasec1&quot;&gt;https://github.com/hey3e/JavaSec-Code/tree/main/javasec1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;（1）序列化与反序列化&quot;&gt;&lt;a href=&quot;#（1）序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;（1）序列化与反序列化&quot;&gt;&lt;/a&gt;（1）序列化与反序列化&lt;/h3&gt;&lt;p&gt;在Java中，我们创建的对象会随着其JVM的销毁而销毁。但有时，我们希望能在其他JVM、或是其他机器上复用这个对象。&lt;strong&gt;序列化&lt;/strong&gt;允许我们将Java对象转换为字节流，便于存储到本地，以及通过网络发送给其他机器。而&lt;strong&gt;反序列化&lt;/strong&gt;允许我们重新将序列化的字节流还原为Java对象。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSec" scheme="https://hey3e.github.io/categories/JavaSec/"/>
    
    
    <category term="反序列化" scheme="https://hey3e.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="反射" scheme="https://hey3e.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
</feed>
