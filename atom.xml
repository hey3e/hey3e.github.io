<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屋妙妙奇米</title>
  
  
  <link href="https://hey3e.github.io/atom.xml" rel="self"/>
  
  <link href="https://hey3e.github.io/"/>
  <updated>2022-04-21T02:58:13.472Z</updated>
  <id>https://hey3e.github.io/</id>
  
  <author>
    <name>yekc1m</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android加固系列-1-Dex101</title>
    <link href="https://hey3e.github.io/2022/04/20/Android%E5%8A%A0%E5%9B%BA%E7%B3%BB%E5%88%97-1-Dex101/"/>
    <id>https://hey3e.github.io/2022/04/20/Android%E5%8A%A0%E5%9B%BA%E7%B3%BB%E5%88%97-1-Dex101/</id>
    <published>2022-04-20T07:43:18.000Z</published>
    <updated>2022-04-21T02:58:13.472Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;工具源码： &lt;a href=&quot;https://github.com/hey3e/DexStrFinder&quot;&gt;https://github.com/hey3e/DexStrFinder&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据被加固的对象，Android加固可以分为两大类：Java层加固与Native层加固。Java层加固，主要针对的是Dex文件。因此，了解Dex是理解Java层加固的基础。&lt;/p&gt;</summary>
    
    
    
    <category term="Android加固" scheme="https://hey3e.github.io/categories/Android%E5%8A%A0%E5%9B%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaSec系列 - 5. SpEL注入</title>
    <link href="https://hey3e.github.io/2022/04/01/JavaSec%E7%B3%BB%E5%88%97-5-SpEL%E6%B3%A8%E5%85%A5/"/>
    <id>https://hey3e.github.io/2022/04/01/JavaSec%E7%B3%BB%E5%88%97-5-SpEL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-04-01T05:38:05.000Z</published>
    <updated>2022-04-02T08:20:05.592Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章源码： &lt;a href=&quot;https://github.com/hey3e/JavaSec-Code/tree/main/javasec5&quot;&gt;https://github.com/hey3e/JavaSec-Code/tree/main/javasec5&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先前，我们在&lt;a href=&quot;https://hey3e.github.io/2021/12/29/JavaSec%E7%B3%BB%E5%88%97-2-JNDI%E6%B3%A8%E5%85%A5/&quot;&gt;系列2&lt;/a&gt;中jdk&amp;gt;8u191的环境下实现JNDI注入时，使用到了EL表达式。SpEL，是EL的一种，”Sp”代表”Spring”，即用于Spring的表达式。而最近，Spring Cloud爆出两个RCE，其原理均为SpEL注入，因此我们下面通过接触这两个实例来了解SpEL注入的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSec" scheme="https://hey3e.github.io/categories/JavaSec/"/>
    
    
    <category term="SpEL" scheme="https://hey3e.github.io/tags/SpEL/"/>
    
  </entry>
  
  <entry>
    <title>JNI 101</title>
    <link href="https://hey3e.github.io/2022/03/02/JNI-101/"/>
    <id>https://hey3e.github.io/2022/03/02/JNI-101/</id>
    <published>2022-03-02T03:31:57.000Z</published>
    <updated>2022-03-03T11:12:14.403Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章参考： 《深入理解Android 卷Ⅰ》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在逆向so文件时，我们经常遇到/发现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找不到Java层native函数对应的JNI函数；&lt;/li&gt;
&lt;li&gt;要把JNI函数的第一个参数改为&lt;code&gt;JNIEnv *env&lt;/code&gt;以便识别；&lt;/li&gt;
&lt;li&gt;加载so时，频繁调用&lt;code&gt;NewStringUTF&lt;/code&gt;、&lt;code&gt;ReleaseStringUTFChars&lt;/code&gt;等字符串函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在深入理解&lt;strong&gt;JNI (Java Native Interface)&lt;/strong&gt; 之后，我们可以解释上述现象。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://hey3e.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://hey3e.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JavaSec系列 - 4. 反序列化与JNDI注入(2)</title>
    <link href="https://hey3e.github.io/2022/01/17/JavaSec%E7%B3%BB%E5%88%97-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8EJNDI%E6%B3%A8%E5%85%A5-2/"/>
    <id>https://hey3e.github.io/2022/01/17/JavaSec%E7%B3%BB%E5%88%97-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8EJNDI%E6%B3%A8%E5%85%A5-2/</id>
    <published>2022-01-17T12:56:45.000Z</published>
    <updated>2022-01-17T13:00:54.386Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章源码： &lt;a href=&quot;https://github.com/hey3e/JavaSec-Code/tree/main/javasec4&quot;&gt;https://github.com/hey3e/JavaSec-Code/tree/main/javasec4&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;深入分析CVE-2021-21344。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSec" scheme="https://hey3e.github.io/categories/JavaSec/"/>
    
    
    <category term="反序列化" scheme="https://hey3e.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="JNDI" scheme="https://hey3e.github.io/tags/JNDI/"/>
    
  </entry>
  
  <entry>
    <title>JavaSec系列 - 3. 反序列化与JNDI注入(1)</title>
    <link href="https://hey3e.github.io/2022/01/17/JavaSec%E7%B3%BB%E5%88%97-3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8EJNDI%E6%B3%A8%E5%85%A5-1/"/>
    <id>https://hey3e.github.io/2022/01/17/JavaSec%E7%B3%BB%E5%88%97-3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8EJNDI%E6%B3%A8%E5%85%A5-1/</id>
    <published>2022-01-17T12:52:58.000Z</published>
    <updated>2022-01-17T12:59:22.049Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章源码： &lt;a href=&quot;https://github.com/hey3e/JavaSec-Code/tree/main/javasec3&quot;&gt;https://github.com/hey3e/JavaSec-Code/tree/main/javasec3&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上章我们了解到，通过控制&lt;code&gt;lookup&lt;/code&gt;方法的参数，可以实现&lt;strong&gt;JNDI注入&lt;/strong&gt;。从控制到注入，就是一条完整的攻击链。我们来看一个实例。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSec" scheme="https://hey3e.github.io/categories/JavaSec/"/>
    
    
    <category term="反序列化" scheme="https://hey3e.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="JNDI" scheme="https://hey3e.github.io/tags/JNDI/"/>
    
  </entry>
  
  <entry>
    <title>JavaSec系列 - 2. JNDI注入</title>
    <link href="https://hey3e.github.io/2021/12/29/JavaSec%E7%B3%BB%E5%88%97-2-JNDI%E6%B3%A8%E5%85%A5/"/>
    <id>https://hey3e.github.io/2021/12/29/JavaSec%E7%B3%BB%E5%88%97-2-JNDI%E6%B3%A8%E5%85%A5/</id>
    <published>2021-12-29T13:39:16.000Z</published>
    <updated>2022-01-04T13:04:19.926Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章源码： &lt;a href=&quot;https://github.com/hey3e/JavaSec-Code/tree/main/javasec2&quot;&gt;https://github.com/hey3e/JavaSec-Code/tree/main/javasec2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命名与目录系统 (Naming and Directory services)，如&lt;strong&gt;RMI&lt;/strong&gt; (Remote Method Invocation)、&lt;strong&gt;LDAP&lt;/strong&gt; (Lightweight Directory Access Protocol) 等，能够以类似字典&lt;code&gt;key-value&lt;/code&gt;的&lt;code&gt;name-object&lt;/code&gt;形式对对象进行存储，使得我们可以通过名称来查询并访问对象。&lt;strong&gt;JNDI&lt;/strong&gt; (Java Naming and Directory Interface) 便是该过程的接口。&lt;/p&gt;
&lt;p&gt;结合上一章的知识，我们考虑在系统中存储对象序列化后的字节流，当用户进行查询时，系统返回对应的字节流，用户再进行反序列化获取对象。但在实际场景中，如果对象过大，采用该方式往往会给系统带来一定的负担。&lt;/p&gt;
&lt;p&gt;于是，JNDI使用&lt;code&gt;Naming References&lt;/code&gt;的方式进行存储，此时，&lt;code&gt;name-object&lt;/code&gt;中的&lt;code&gt;object&lt;/code&gt;并非对象本身，而是对象的引用&lt;code&gt;Reference&lt;/code&gt;，其中包含对象名及其真正被存放的地址codebase。当用户进行查询时，系统返回&lt;code&gt;Reference&lt;/code&gt;，用户解析后再从codebase获取对象。&lt;strong&gt;不过这里说的不太严谨，后面会进行补充&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过，上述从远程codebase加载对象的方式存在许多安全问题，随着jdk版本的迭代，系统对codebase已逐渐不再信任，JNDI受到越来越多的限制。我们下面看一下各版本下JNDI如何实现。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSec" scheme="https://hey3e.github.io/categories/JavaSec/"/>
    
    
    <category term="JNDI" scheme="https://hey3e.github.io/tags/JNDI/"/>
    
  </entry>
  
  <entry>
    <title>JavaSec系列 - 1. 反序列化与反射</title>
    <link href="https://hey3e.github.io/2021/12/22/JavaSec%E7%B3%BB%E5%88%97-1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>https://hey3e.github.io/2021/12/22/JavaSec%E7%B3%BB%E5%88%97-1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2021-12-22T13:45:42.000Z</published>
    <updated>2021-12-27T13:01:10.154Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章源码： &lt;a href=&quot;https://github.com/hey3e/JavaSec-Code/tree/main/javasec1&quot;&gt;https://github.com/hey3e/JavaSec-Code/tree/main/javasec1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;（1）序列化与反序列化&quot;&gt;&lt;a href=&quot;#（1）序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;（1）序列化与反序列化&quot;&gt;&lt;/a&gt;（1）序列化与反序列化&lt;/h3&gt;&lt;p&gt;在Java中，我们创建的对象会随着其JVM的销毁而销毁。但有时，我们希望能在其他JVM、或是其他机器上复用这个对象。&lt;strong&gt;序列化&lt;/strong&gt;允许我们将Java对象转换为字节流，便于存储到本地，以及通过网络发送给其他机器。而&lt;strong&gt;反序列化&lt;/strong&gt;允许我们重新将序列化的字节流还原为Java对象。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSec" scheme="https://hey3e.github.io/categories/JavaSec/"/>
    
    
    <category term="反序列化" scheme="https://hey3e.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="反射" scheme="https://hey3e.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
</feed>
